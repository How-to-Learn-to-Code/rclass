---
title: "HTLTC-R: Plotting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{HTLTC-R: Plotting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE)
```

### Using this document

* Code blocks and R code have a grey background (note, code nested in the text is not highlighted in the pdf version of this document but is a different font).
* \# indicates a comment, and anything after a comment will not be evaluated in R
* The comments beginning with \#\# under the code in the grey code boxes are the output from the code directly above; any comments added by us will start with a single \#
* While you can copy and paste code into R, you will learn faster if you type out the commands yourself. 
* Read through the document after class. This is meant to be a reference, and ideally, you should be able to understand every line of code. If there is something you do not understand please email us with questions or ask in the following class (you're probably not the only one with the same question!). 

### Goals
1. Understand the basics of the graphics system
2. Know the different plotting regions
3. Know the different coordinate systems
4. Learn the basic graphics tools to draw & annotate custom plots

### The R graphics system

R has two engines for graphing: the *graphics* engine and the *grid* engine. The grid engine is arguably more flexible, but also more complicated. In this class we will only discuss the graphics engine. Before we start discussing the details of the engine, we will illustrate some of the basic plotting functionality. The most common starting for a plot is calling the `plot` function. This function is essentially a wrapper for MANY functions that give you an easy way to make a very basic plot. 

```{r,fig.width=4,fig.height=3,fig.align='center'}
plot(0)
```

The `plot` function will take many data types and structures, and will produce different plots based on the input. 

```{r,fig.show='hold',fig.width=3.4}
plot(matrix(1:10, ncol = 2)) # scatterplot
plot(data.frame(rep(letters[1:5], each = 2), 1:10)) # boxplot
```

There are many guides on how to change the parameters of `plot`, as well as other high-level functions like `barplot`, `boxplot`, `hist`, etc. A good first step is to read through `?plot`. Rather than belabor lists of arguments, we will discuss the fundamentals of the grahics system. 

### Plotting devices

Both the graphics and the grid system start with the generation of a plotting device. The creation and management of devices are controlled by the `dev.*` functions. In addition to the `dev.*` functions there are many special device functions (`pdf`, `png`, etc.) that open a device and write directly to a file. Note: when using one of the special graphics drivers none of the graphics are shown until the device is closed and the generated file is opened. Using these device calls will allow generating high-quality manuscript-ready figures. At any time we can look at the open devices using `dev.list()` and `dev.cur()`.

```{r,echo=-1}
invisible(dev.off(2))
# We start with no open devices
dev.list()
dev.cur() # lists the active device, here null because no device open
pdf() # open a new pdf device
dev.list() # 1 is not shown, but always represents the null device
dev.cur()
pdf()
dev.list()
dev.cur()
dev.set(2)
dev.cur()
dev.off(2); dev.off(3)
```

With the exception of `dev.list`, the value returned by the `dev.` functions is the current device after the function call. We can see opening and closing devices change the current device. 

### Drawing regions

The next step in the process is to define the drawing regions. The drawing regions are set by calling `plot.new()`. `plot.new()` establishes the drawing regions in the device based on the current settings of `par()`. The `par()` function stores the current plotting parameters. Reading `?par` is incredibly valuable. Here, we will only go over a select number of the plotting parameters. Running `par()` returns a named list with one element per parameter.

```{r}
length(par()) # There are MANY parameters
# Easiest to call the parameter of interest by name, here we are just
# telling R to subset the returned list with the `$` operator.
par()$mar 
# The values for parameters can be changed by setting them within the
# function.
par(mar = c(1, 1, 1, 1))
par()$mar
```

`par()` controls everything from default colors and plotting symbols to the style of the default axes. ***It is important to understand that everytime a new device is created `par()` is reset to the defaults.*** Here we are interested in the drawing regions and how to define them. The figure below illustrates the three regions. 

```{r,echo=FALSE}
line2user <- function(line, side) {
  lh <- par('cin')[2] * par('cex') * par('lheight')
  x_off <- diff(grconvertX(c(0, lh), 'inches', 'npc'))
  y_off <- diff(grconvertY(c(0, lh), 'inches', 'npc'))
  switch(side,
         `1` = grconvertY(-line * y_off, 'npc', 'user'),
         `2` = grconvertX(-line * x_off, 'npc', 'user'),
         `3` = grconvertY(1 + line * y_off, 'npc', 'user'),
         `4` = grconvertX(1 + line * x_off, 'npc', 'user'),
         stop("Side must be 1, 2, 3, or 4", call.=FALSE))
}
col2alpha <- function(col, alpha = 0.5) {
  tmp <- col2rgb(col)
  rgb(tmp[1]/255, tmp[2]/255, tmp[3]/255, alpha)  
}
labelLines <- function(outer = FALSE, alpha = 1) {
  if (outer) {
    col <- col2alpha("darkgreen", alpha)
    p <- "oma"
    a <- par()$mar
  } else {
    col <- col2alpha("darkred", alpha)
    p <- "mar"
    a <- rep(0, 4)
  }
  nline <- par()[[p]]
  side <- unlist(mapply(rep, 1:4, each = nline))
  line <- unlist(sapply(nline, seq)) - 1
  txt <- paste0("Line", line)
  mtext(txt, side, line, outer = outer, col = col)
  mtext(paste0("Side", 1:4), 1:4, -1, col = col2alpha("gray40", alpha))
  abline(h = line2user(0:nline[1] + a[1], 1), xpd = NA, lty = 3, col = col)
  abline(v = line2user(0:nline[2] + a[2], 2), xpd = NA, lty = 3, col = col)
  abline(h = line2user(0:nline[3] + a[3], 3), xpd = NA, lty = 3, col = col)
  abline(v = line2user(0:nline[4] + a[4], 4), xpd = NA, lty = 3, col = col)
}
setupPlot <- function(label.lines = FALSE) {
  par(mar = c(2, 5, 2, 2), oma = c(2, 5, 2, 2))
  plot.new()
  plot.window(xlim = c(1, 10), ylim = c(1, 10))
  if (label.lines) {
    labelLines()
    labelLines(TRUE)
  } else {
    mtext(side = 3, text = "Plot region", line = -1.5, col = "gray40")
    mtext(side = 3, text = "Figure region", line = 0.5, col = "darkred")
    mtext(side = 3, text = "Device region", line = 2.5, col = "darkgreen")
  }
  box(which = "plot", lwd = 2, col = "gray40")
  box(which = "figure", lwd = 2, col = "darkred")
  box(which = "outer", lwd = 4, col = "darkgreen")
}
```
```{r,echo=FALSE,fig.width=6,fig.height=4.5,fig.align='center'}
setupPlot()
```


The device region is simply the device we are plotting in -- controlled by the size of the device. The figure and plotting regions are defined relative to the size of the device. The size interactive devices -- like the one built into RStudio -- can be changed. The size of static devices (like the device created by `pdf()`) are defined when the device is created (eg. the *`width`* and *`height`* parameters in `pdf`). The figure and plotting regions are defined by the `oma` and `mar` settings in `par()`. `oma` stands for "outter margins" -- meaning the number of lines of text between the figure region and the edge of the device. `mar` stands for "margins" -- meaning the number of lines of text between the plotting region and the edge of the figure region. Each setting takes a numeric vector of the format `c(bottom, left, top, right)`. The above figure was created by setting both *`oma`* and *`mar`* to `c(2, 5, 2, 2)`.

```{r,echo=FALSE,fig.width=6,fig.height=4.5,fig.align='center'}
setupPlot(TRUE)
```

The above plot is key in understanding how to draw things within the graphics engine. Many of the drawing functions rely on specifying the side, line, and whether to draw in the outer margins. Notice the "0" line rests on the interior drawing region, eg. the inner line 0 rests on the plotting region and the outer line 0 rests on the figure region. Here the text is drawn such that it is justfied above the line. 

By default, `par()$oma = c(0, 0, 0, 0)` -- meaning that R does not typically include any outer margins and the figure region fills the whole device. We can think of the plotting region as the space where the data goes, and the figure margin space as where we draw the axes, axis labels, title, etc. WHen using the high-level plotting functions, such as `plot`, R will define the scale of the plotting region based on the supplied data. Here the scale means what values fit into the x and y axes, eg. x ranges from 0 to 100 and y ranges from 5 to 6. Only data within the scale of the plotting region will be included (unless we tell R otherwise -- more on that later). The scale of the plotting region is stored by `usr`. Now we will go through the first couple steps of constructing a plot from scratch, tracking how each step effects `par()$usr`. 

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
# usr is c(x-min, x-max, y-min, y-max)
par()$usr # c(0, 1, 0, 1) by default
plot.new() # setup a new plot 
par()$usr
plot.window(xlim = c(0, 100), ylim = c(5, 6))
par()$usr
# Note the default margins
par()$mar
labelLines(alpha = 0.5) # custom function for illustration (ignore)
```

First note you do not need to call a new device manually, `plot.new` will handle that for you. Second, note that `plot.window` behaves differently than setting *`usr`* directly with `par`. Using `plot.window` adds 4\% to the given range (the default behavior). When using `plot`, R finds the range of the given data and adds 4\%. Here we can see the span of 5 and 6 is 1, so 0.04 is added and subtracted giving the final *`usr`* values. 

### Drawing in graphics

Now that we have the ability to call a new device define the drawing regions, we will discuss how to draw the plot elements in the device. Both the graphics and grid engines use follow a paint-like system for drawing. Each addition to the device is "painted" on, meaning that the first of overlapping drawings will be covered by subsequent drawings. The following code illustrates this.

```{r,fig.width=6,fig.height=4,fig.align='center'}
plot.new()
par(mar = rep(0, 4), usr = c(0, 3, 0, 2))
polygon(x = c(0.9, 0.9,  1.1, 1.1), 
        y = c(0.9, 1.1,  1.1, 0.9),
        col = col2alpha("darkblue", 0.5),
        border = NA)
polygon(x = c(0.6, 0.6,  1.4, 1.4), 
        y = c(0.6, 1.4,  1.4, 0.6),
        col = col2alpha("darkred", 0.5),
        border = NA)
polygon(x = c(0.9, 0.9,  1.1, 1.1) + 1, 
        y = c(0.9, 1.1,  1.1, 0.9),
        col = "darkblue",
        border = NA)
polygon(x = c(0.6, 0.6,  1.4, 1.4) + 1, 
        y = c(0.6, 1.4,  1.4, 0.6),
        col = "darkred",
        border = NA)
```

Here we use a custom function to make the colors transparent for the left squares, drawn by the function `polygon`. You can see R draws the blue square first, then the red square over the blue square. `polygon` works by drawing a polygon with vertices at the given x and y cooridnates. Note that `polygon` will complete the path to the starting point, ie. we did not need to add the starting point at the end of each vector. (We chose to use `par` to set the scale of the plotting region without margins, so that we could specify the device size -- 6\"x4\" -- such that the drawings were exactly square.) 

We will now go through the functions needed to add the common plot elements, discussing how to customize each element. Consider the following plot:

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
x <- seq(0, 100, length.out = 10)
y <- seq(5, 6,   length.out = 10)
plot.new()
plot.window(xlim = c(0, 100), ylim = c(5, 6))
box() # Draws the outer frame
axis(side = 1) # Draws the x-axis (recall the side definitions!)
axis(side = 2) 
mtext(side = 1, "x-axis", line = 3) # Draws text in the margin 
mtext(side = 2, "y-axis", line = 3) 
title(main = "A plot to learn from") # Draws the title
points(x = x, y = y) # Draw points on the plot
legend(x = "topleft", legend = "Some data", pch = 1) # Finally, draw a legend
```

First note, the above plot (excluding the legend) can be created using the `plot` command:

```{r,eval=FALSE}
plot(x = x, y = y, 
     xlab = "x-axis", 
     ylab = "y-axis", 
     main = "A plot to learn from")
```

However, we want to understand the individual components so that we can easily customize the plot to prepare manuscript-ready figures without any manual manipulation. 

Keep in mind there are many ways to skin a cat! We will use `x` and `y` as defined above and initiate each plot with `plot(x = x, y = y, ann = FALSE, axes = FALSE, type = "n")`. This is a shortcut to calling `plot.new` and then `plot.window`. The call to `plot` says plot this data with no annotations (axis labels or title), no axes, and with type "n" (meaning don't draw the points, either). Note, the *`axes = FALSE`* also suppresses the plot frame. It saves a couple lines of code and does the dirty work of defining the scale of the plotting region for us. Best of all, it demonstrates another way to accomplish the same task. For each of the following sections we will discuss one aspect of the plot. For each function we encourage reading the help page. 

### Plot frame

To frame or not to frame? As mentioned above, setting *`axes = FALSE`* when calling `plot` suppresses the plotting frame. Some people like include a frame around the plot, others do not. When starting with a blank canvas the `box` function draws a frame around the plotting region.

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
par(oma = rep(1, 4))
plot(x = x, y = y, ann = FALSE, axes = FALSE, type = "n")
box() # default, which = "plot"
box(which = "inner", col = "red")
box(which = "outer", col = "blue")
```

By default, `box` draws a frame around the figure region. Here we see it can also draw frames around the figure and device regions. Notice the blue line (device region) is half as thick as the others -- this occurs because the line is drawn on the border, so half of the line is off the device. One way to remedy this is by changing the line thickness, controlled by the parameter *`lwd`*, eg. `box(which = "outer", col = "blue", lwd = 2)`.

### Axes

The default position of the axes is controlled by the *`mgp`* setting, which specifies the margin line location for the axis title, tick labels, and axis line, respectively. By default *`mgp`* is `c(3, 1, 0)`. This gives some insight as to why the default margin sizes are `c(5, 4, 4, 2) + 0.1`. R leaves room for axes on the bottom and left sides (sides 1 and 2, respectively). There is additional room left on the bottom for a subtitle, and room left on the top for the title. We draw axes with the `axis` function, which allows you to override any of the defaults. Consider the following: 

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
plot(x = x, y = y, ann = FALSE, axes = FALSE, type = "n")
box()
axis(side = 1, line = 1)
axis(side = 2, line = 1)
```

We used the *`line`* parameter to override the default axis location, drawing the axis at margin line 1 rather than 0. Suppose we want a plot where the x and y axes lay on the 0 lines rather than the edge of the plot. Here we need to use the *`pos`* parameter. We do not know which *`line`* represents the center of the plot, but *`pos`* takes values in the plotting region. Note, specifying *`pos`* overrides any specification of *`line`*.

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
plot(x = -5:5, y = -5:5, ann = FALSE, axes = FALSE, type = "n")
axis(side = 1, pos = 0, line = 0) # this shows how pos overrides line
axis(side = 2, pos = 0)
```

Now the axes are where we want, but the ticks and labels still need work. 

```{r,fig.width=4.5,fig.height=4.5,fig.align='center'}
par(mar = rep(0, 4))
plot(x = -5:5, y = -5:5, ann = FALSE, axes = FALSE, type = "n")
loc <- c(-5:-1, 1:5)
lbl <- c(-5, rep("", 8), 5)
axis(side = 1, pos = 0, at = loc, labels = NA, tcl = 0.5)
axis(side = 2, pos = 0, at = loc, labels = NA, tcl = 0.5)
axis(side = 1, pos = 0, at = loc, cex.axis = 0.75, labels = lbl)
axis(side = 2, pos = 0, at = loc, cex.axis = 0.75, labels = lbl, las = 2)
```

The `axis` function only draws tick marks on one side of the axis. The length of the tick marks is controlled by *`tcl`*, which specifies the length as a fraction of the height of a line of text. The default is -0.5, meaning draw a half-character height tick mark away from the plotting region. Here we used two calls to `axis` for each axis to create ticks that point in both directions. We also specified the tick locations with *`at`* and the tick labels with *`labels`*. The label sizes are controlled by *`cex.axis`* and the y-axis labels were rotated with *`las`*. Again, it is really helpful to read `?par` to better understand each of these settings. *`cex`* controls text size, specifying how much the "plotting text and symbols should be magnified relative to the default". Here, *`cex.axis`* is a special setting which only affects the axis label text. 

### Titles

Titles are most simply drawn with the `title` function.

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
par(mar = c(5, 4, 8, 2) + 0.1)
# bty = "n" suppresses the frame; read ?par for more info!
plot(x = x, y = y, ann = FALSE, bty = "n", type = "n")
labelLines(alpha = 0.2)
title(main = "Title w/\n2 lines", xlab = "x", ylab = "y", sub = "Sub title")
```

Notice in "A plot to learn from" we used `mtext` in place of `title` to draw the axis titles. We can think of `title`  as making calls to `mtext` to specify the axis titles and the subtitle (although not technically true). Again, the location of the axis titles is controlled by *`mgp[1]`*, and the location of the subtitle defaults to *`mgp[1] + 1`* (which is why the default bottom margin has 1 more line than the default left margin!). We see the the position of the main title is centered in the top margin space. The main title can be moved to the outer margins by setting *`outer = TRUE`*. 

### Adding data

As with `title` and `mtext`, we can think of `plot` calling another function -- `points` -- to draw the data (again, technically not true, but useful to conceptualize the plotting). 

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
plot(x = x, y = y, ann = FALSE, bty = "n", type = "n")
points(x = x, y = y)
```

`points` adds plot symbols at the given coordinates. First, we will discuss the different point "types" specified by the *`type`* parameter. From the documentation, *`type`* is a:

> 1-character string giving the type of plot desired. The following values are possible, for details, see plot: "p" for points, "l" for lines, "b" for both points and lines, "c" for empty points joined by lines, "o" for overplotted points and lines, "s" and "S" for stair steps and "h" for histogram-like vertical lines. Finally, "n" does not produce any points or lines.

```{r,fig.width=7,fig.height=7,fig.align='center',results='hide',echo=FALSE}
drawType <- function(type) {
  plot(x = x, y = y, ann = FALSE, axes = FALSE, type = type)
  box()
  title(main = sprintf("Type = \"%s\"", type))
}
par(mfrow = c(3, 3))
sapply(c("p", "l", "b", "c", "o", "s", "h", "n"), drawType)
```

We can also customize the plotting symbols, their color, and size. 

```{r,fig.width=6,fig.height=4.5,fig.align='center'}
plot(x = x, y = y, ann = FALSE, bty = "n", type = "n")
sz <- seq(0.5, 1.5, length.out = 10)
points(x = x, y = y, col = "darkred", pch = letters[1:10], font = 2, cex = sz)
points(x = x, y = y, col = "darkblue", type = "c", lwd = 2)
```

The above figure highlights a lot of new parameters. *`col`* defines the color, *`pch`* defines the plotting symbol (here we used letters), *`cex`* (as discussed above) defines the relative size of the symbols, and *`font = 2`* tells the function to plot the bold version of the letters. *`type = "p"`* by default, so the first call to `points` just drew the red letters. The second call drew the blue lines (with double line thickness) between the symbols. Notice the parameters can take vectors, specifying different values for each point. There are many options for plotting symbols, which are summarized below[^1]:

[^1]: http://rgraphics.limnology.wisc.edu/pch.php

```{r,echo=FALSE,fig.width=6,fig.height=6,fig.align='center'}
# Taken from http://rgraphics.limnology.wisc.edu/pch.php
pchShow <-
  function(extras = c(".", "o", "O", "0","a","A", "*", "+","-","|"),
           symbolsize = 3, #
           symbolcolor = "red3",
           fillcolor = "slateblue3",
           linewidth = 1,
           textcolor = "black",
           textsize = 1.2,
           main = paste("Plot symbols in R")
           )
  {

# Organize symbols & characters to be plotted
# --------------------------------------------------------------------------

    nex <- length(extras)            # number of char graphics symbols to plot
    n_points  <- 26 + nex            # total number of symbols to plot
    ipch <- 0:(n_points-1)           # sequence of pch id numbers (0,1,2,...25)

    # create list of pch values (0:25); ('list' allows integers & strings)
    pchlist <- as.list(ipch)

    # Add the special characters to the list (if any)
    if(nex > 0) pchlist[26 + 1:nex] <- as.list(extras)

# Set up graphing space for display of symbols
# --------------------------------------------------------------------------
    # no. of columns to display in graph
    # (selected such that plot is close to square, nrows ~= ncols)
    k <- floor(sqrt(n_points))

    dd <- c(-1,1)/2             # padding of graph (+ 0.5 units on each side)

    # x coordinates for plotting symbols ('a %% b' means 'a modulus b';
    # that is, divides a by b and returns the remainder.)
    ix <- ipch %% k

    # y coordinates for plotting symbols ('a %/% b' indicates integer division,
    # that is, it returns the integer portion of the quotient only)
    iy <- 3 + (k-1)- ipch %/% k
    
    rx <- dd + range(ix)        # full range of x axis
    ry <- dd + range(iy)        # full range of y axis

    # create plot window
    plot(rx, ry, type="n", axes = FALSE, xlab = "", ylab = "", main = main)

    # display grid lines
    abline(v = ix, h = iy, col = "lightgray", lty = "dotted")

# Plot symbols and symbol labels (loops through each symbol type)
# --------------------------------------------------------------------------

    for(i in 1:n_points) {
      # for each value, i, get symbol id from list created ealier
      pch_i <- pchlist[[i]]

      # plot point at x(i), y(i), using the selected symbol.
      # Colors and size determined above
      # 'bg'-colored interior (only available for pch 21-25) :
      points(ix[i], iy[i], pch = pch_i, col = symbolcolor, bg = fillcolor,
          cex = symbolsize, lwd=linewidth)
      if(textsize > 0)
          text(ix[i] - .3, iy[i], pch_i, col = textcolor, cex = textsize)
    }
  }

pchShow(symbolsize = 2)

``` 

### Other objects

lines, polygon, abline, arrows, curve, segments

```{r,fig.width=6,fig.height=4.5,fig.align='center',eval=FALSE,echo=FALSE}
plot.new()
par(usr = c(0, 8, 0, 10), mar = rep(0, 4))
polypath(x = c(2, 2, 6, 6, NA, 3, 6, 4),
         y = c(2, 6, 6, 2, NA, 4, 8, 4),
         col = "gray", rule = "evenodd")
```

### Adding text -- Dayne

Text alignment 
Identify function

```{r}
plot.new()
```


### Colors in R? -- Siyao

### Coordinate systems -- Dayne

### Legends -- Siyao

Mention columns. Show line vs fill vs points. Mention bty. Mention alignment
is analagous to text alignment. 

### Plotmath -- Dayne

We will not discuss the details of using plotmat, but it is helpful to know it exists.

### Organizing multiple plots -- Siyao

```{r,fig.width=6.5,fig.height=4.5,fig.align='center'}
par(mfrow = c(1, 2), oma = c(2, 1, 4, 1), mar = c(5, 4, 4, 2))
plot(x = x, y = y, ann = FALSE, axes = FALSE, type = "n")
labelLines(outer = TRUE)
box(which = "outer", col = "darkgreen", lwd = 4)
box(lwd = 2, col = "gray40")
box(which = "figure", lwd = 2, col = "darkred")
labelLines()
plot(x = x, y = y, ann = FALSE, axes = FALSE, type = "n")
box(lwd = 2, col = "gray40")
box(which = "figure", lwd = 2, col = "darkred")
labelLines()
```

### Common plotting functions -- Siyao

hist, barplot, boxplot, pairs

mention how to store the output, such that you know the coordinates

### Exercises -- Dayne

1. Create a ruler

2. 


